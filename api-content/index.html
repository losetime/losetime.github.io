{"posts":[{"title":"快速排序","content":" function quickSort(arr, l, r){ if(l&gt;=r) return arr let left = l // 左指针 let right = r //右指针 let pivot = arr[left] // 基准值 // 开启排序 while(left &lt; right){ // 如果左指针小于右指针，才能继续，否则说明两个指针相遇了 while(arr[left]&lt;pivot &amp;&amp; left&lt;right){ left++ } while(arr[right]&gt;pivot &amp;&amp; left&lt;right){ right-- } if(left&lt;right){ [arr[left],arr[right]] = [arr[right],arr[left]] } else { arr[left]=pivot } } quickSort(arr, l, left-1) quickSort(arr, left+1, r) return arr } let sortArr = [2,1,4,3,9,12,100,201,29,80,72,92,54,32,23] console.log(quickSort(sortArr, 0, sortArr.length-1)) ","link":"https://losetime.github.io/post/kuai-su-pai-xu/"},{"title":"实现一个任务队列","content":"1.promise实现任务队列 promise.then如果遇到没有返回值，那么默认就会把undefined包装成promise后返回，然后继续向下执行 我们在返回值里 返回一个新的promise，那么第一层的promise就会等到这内部的promise执行完毕后才会返回 而内部的promise什么时候执行完成，就依赖于resolve何时执行，这就达到了任务队列的目的 1. forEach版本 function taskQueue(arr){ let promise = Promise.resolve(); arr.forEach(item=&gt;{ //这里需要把返回的Promise实例赋给promise，生成新的队列 promise = promise.then(()=&gt;{ return new Promise(resolve=&gt;{ // do... setTimeout(()=&gt;{ console.log(item) resolve(); },2000) }) }) }) } 2. reduce版本 function taskQueue(arr){ /** * reduce方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终返回一个值 * reduce中callback的返回值会作为下一次的初始值 reduce参数 * callback，回调函数 * initialValue，初始传入值值 callback参数 * 1.previousValue,上一次调用回调返回的值，或者是提供的初始值 * 2.currentValue，数组中当前被处理的元素 * 3.index,当前元素在数组中的索引 * 4.array,reduce调用的数组 */ arr.reduce((promise,item,index,array)=&gt;{ return promise.then(()=&gt;{ return new Promise(resolve=&gt;{ setTimeout(()=&gt;{ console.log(item) resolve(); },2000) }) }) },Promise.resolve()) } ","link":"https://losetime.github.io/post/shi-xian-yi-ge-ren-wu-dui-lie/"},{"title":"Vue CLI Plugin Electron Builder笔记","content":"1.环境变量说明 vue.js中设置的【生产环境变量】和【线上环境变量】在electron打包是可用的 2.隐藏顶部菜单栏 3.使用electron-build在vue-cli 3中的使用 文档参考：https://nklayman.github.io/vue-cli-plugin-electron-builder/guide/#installation 安装完毕之后项目里会多出一些文件，其中有一个background.js，关于页面的东西需要去这个当中改 注意事项:node版本必须高于8.12，升级node版本后可以后导致node-sass这个模块的不可用，需要执行【npm rebuild node-sass】去重新绑定 4.窗口宽与高的固定 win = new BrowserWindow({ width: 400, height: 750, maxHeight:750, maxWidth: 400, webPreferences: { nodeIntegration: true } }); 4.应用打包后打开调试工具 方法一（主进程）： function createWindow (){ mainWindow = newBrowserWindow({ width:800, height:600 }) mainWindow.webContents.openDevTools() } 方法二（渲染进程）： const { remote } = require('electron') remote.getCurrentWebContents().openDevTools() 6.替换图标 1.把图标放在public文件下 2.安装 yarn add --dev electron-icon-builder（需要科学上网） 3.添加命令： &quot;electron:generate-icons&quot;: &quot;electron-icon-builder --input=./public/icon.png --output=build --flatten&quot; 4.生成： yarn electron:generate-icons 5.会生成build文件，不要动 6.修改配置 7.打包配置（科学上网很重要啊） 参考文章：https://www.jianshu.com/p/1dbb96bc8f37 参考文档：https://www.electron.build/configuration/configuration module.exports = { pluginOptions: { electronBuilder: { builderOptions: { appId: &quot;com.example.app&quot;, productName: &quot;hsl-Download&quot;, //项目名，也是生成的安装文件名，即hsl-Download copyright: &quot;Copyright © 2019&quot;, //版权信息 directories: { output: &quot;./dist&quot; //输出文件路径 }, win: { //win相关配置 target: [ { target: &quot;nsis&quot;, //利用nsis制作安装程序 arch: [ &quot;x64&quot;, //64位 &quot;ia32&quot; //32位 ] } ] }, nsis: { oneClick: false, // 是否一键安装 allowElevation: true, // 允许请求提升。 如果为false，则用户必须使用提升的权限重新启动安装程序。 allowToChangeInstallationDirectory: true, // 允许修改安装目录 installerIcon: &quot;./static/icon.ico&quot;, // 安装图标 uninstallerIcon: &quot;./static/icon.ico&quot;, //卸载图标 installerHeaderIcon: &quot;./static/icon.ico&quot;, // 安装时头部图标 createDesktopShortcut: true, // 创建桌面图标 createStartMenuShortcut: true, // 创建开始菜单图标 shortcutName: &quot;hsl-Download&quot; // 图标名称 } } } } }; 8.注意事项 1.mac版本必须在mac电脑电脑上打包 9.遇到的错误 1.打包时项目路径中不能有中文。报错如下： ","link":"https://losetime.github.io/post/vue-cli-plugin-electron-builder-bi-ji/"},{"title":"二叉树算法原理","content":"1. 二叉树特点 左子树 &lt; 父节点 &lt; 右子树 2. 中序遍历 先遍历左子树，再访问父节点，再遍历右子树, 可以实现从小到大的排序 3. 前序遍历 先访问父节点，再遍历左子树，再遍历右子树 可以实现复制一颗二叉树，比重新构建二叉树快十倍左右 4. 后序遍历 先遍历左子树，再遍历右子树，再访问父节点 可以应用到文件系统的中，先访问它的左右子树，最后来访问这个节点本身 5. 二叉树查找 最小值：递归查找左子树 最大数：递归查找右子树 具体数：先判断大于父节点还是小于父节点，如果小于父节点，进入左子树；如果大于父节点，进入右子树；递归查找 6. 二叉树子节点的删除,最终目标是保持二叉树的排序性 7.具体实现 function BinaryTree(){ this.root = null; var Node = function(key){ this.key = key; this.left = null; this.right = null; } var insertNode = function(node,newNode){ if(newNode.key &lt; node.key){ if(node.left === null){ node.left = newNode; }else{ insertNode(node.left,newNode) } }else{ if(node.right === null){ node.right = newNode }else{ insertNode(node.right,newNode) } } } this.insert = function(key){ let node = new Node(key); if(this.root === null){ this.root = node; }else { insertNode(this.root,node); } } var inOrderTravelNode = function(node,callback){ if(node!==null){ inOrderTravelNode(node.left,callback); callback(node.key); inOrderTravelNode(node.right,callback); } } // 中序遍历 this.inOrderTravel = function(callback){ inOrderTravelNode(this.root,callback) } var searchNode = function(node,key){ if(node === null){ console.log(&quot;查找失败&quot;); } else if(node.key &gt; key){ searchNode(node.left,key); }else if(node.key &lt; key){ searchNode(node.right,key); }else { console.log(&quot;找到了&quot;); } } //具体值查找 this.search = function(key){ if(this.root !== null){ searchNode(this.root,key); } } //查找右子树最小节点(也就是当前父节点的右子树的左子树) var findMinNode = function(node){ if(node){ while(node &amp;&amp; node.left !== null) { node = node.left; } return node; } return null; } var that = this; var removeNode = function(node,key){ if(node === null){ console.log(&quot;查找失败&quot;); } else if(node.key &gt; key){ node.left = removeNode(node.left,key); return node; }else if(node.key &lt; key){ node.right = removeNode(node.right,key); return node; }else { //没有子节点 if(node.left === null &amp;&amp; node.right === null){ node = null; console.log(&quot;该节点已删除&quot;); return node; } //一个子节点 if(node.left === null){ node = node.right; return node; } else if(ndoe.right === null) { node = node.left; return node; } // 两个子节点，从右子树里找到最小子节点，然后替换父节点的值，并删除这个最小子节点 var minNode = findMinNode(node.right); node.key = minNode.key; node.right = removeNode(node.right,minNode); return node; } } //删除子节点 this.remove = function(key){ this.root = removeNode(this.root,key); } } let node = [10,3,5,6,7,2,12,4,18,9,1] let binaryTree = new BinaryTree(); //创建二叉树 node.forEach(key=&gt;{ binaryTree.insert(key); }) var callback = function(key){ console.log(&quot;中序遍历：&quot;+key); } // 中序遍历 binaryTree.inOrderTravel(callback); // 二叉树查找子节点 binaryTree.search(7); //二叉树删除子节点 binaryTree.remove(1); ","link":"https://losetime.github.io/post/er-cha-shu-suan-fa-yuan-li/"},{"title":"Jenkins配置邮件通知","content":"1. 自带邮件配置 打开全局系统配置，配置Jenkins Location，见图。 全局系统配置，配置邮件通知，见图。 这里说一下，怎么打开邮箱的SMTP服务，这是QQ邮箱的教程：https://jingyan.baidu.com/article/0f5fb099dffe7c6d8334ea31.html 其他邮箱应该大同小异，可以去找找。不过建议不要用Gmail，会牵扯到科学上网的问题。 配置任务构建后操作 打开单项任务的配置-----》构建后操作 ，选择下图 写入邮件地址即可，保存 收到的邮件如下图，可以看到，这只是构建中打印的日志文件，看起来太费劲。不过，如果你只是想知道构建是否失败了，这个还是可以用的。 2. 插件Extended E-mail Notification配置 这个插件增强了邮件功能，使邮件可以自定义，如果没安装就去搜索并安装一下，然后我们一起走一遍过程。 说明一点：如果你直接用插件配置，是可以不用配置系统自带邮件的，这个经过验证。 首先，在系统设置里找到这个插件，然后如图所示配置 点开上图【高级...】，配置如下图 点开上图【Default Triggers】，根据需要选择发送邮件的条件，可以选择总是，也可以选择其他特殊情况。 应用，保存。 打开任务配置，打开【构建后操作】列表 设置触发条件 其他都可以不用动，应用，保存。 逻辑是我们在全局设置了配置好了模板，这边添加一个构建动作，然后执行就可以，也可以在这边配置基于项目的个性化需求。 ","link":"https://losetime.github.io/post/jenkins-pei-zhi-you-jian-tong-zhi/"},{"title":"Jenkins的在Liunx系统上的权限问题","content":"由于Jenkins在安装的时候，会自动创建一个名为jenkins的普通账号，这个账号没有管理员权限。jenkins执行命令的时候，它也会使用这个账号。但是由于nginx这个文件夹是用户root创建的，所以jenkins账号默认是没有权限读写这个文件夹的。所以导致构建的项目总是在复制的时候失败。 下来以centOS系统为例，修改Jenkins配置文件。 打开配置文件 vim /etc/sysconfig/jenkins 修改$JENKINS_USER $JENKINS_USER=&quot;root&quot; 修改Jenkins相关文件夹用户权限 chown -R root:root /var/lib/jenkins chown -R root:root /var/cache/jenkins chown -R root:root /var/log/jenkins 重启Jenkins服务并检查运行Jenkins的用户是否已经切换为root service jenkins restart 查看Jenkins进程所属用户 ps -ef | grep jenkins 若显示为root用户，则表示修改完成 ","link":"https://losetime.github.io/post/jenkins-de-zai-liunx-xi-tong-shang-de-quan-xian-wen-ti/"},{"title":"阿里云CentOS配置Jenkins","content":"1. 下载jenkins #下载Jenkins库 wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat/jenkins.repo #导入key rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key #安装Jenkins，`-y`参数：回答全部问题为是 yum install -y jenkins #启动Jenkins服务 systemctl start jenkins 或者 service jenkins start jenkins的安装地址： /var/lib/jenkins/ Jenkins目录、端口、工作目录等信息在： /etc/sysconfig/jenkins 注意： 要安装java yum install java-1.8.0-openjdk 阿里云的安全组规则，千万要记得把阿里云的安全组规则里加上自己要访问的端口 防火墙问题 cat /var/log/jenkins/jenkins.log #查看安装日志安装没有问题 firewall-cmd --add-port=8080/tcp #将设置的端口防火墙关闭 2. 配置jenkis的端口 vi /etc/sysconfig/jenkins 找到修改端口号： JENKINS_PORT=&quot;8080&quot; 此端口不冲突可以不修改 3. 启动jenkins service jenkins start/stop/restart 4. 生成Personal Access Token 进入github --&gt; setting --&gt;developers--&gt; Personal Access Token --&gt; Generate new token, 新建一个有读写权限的用户 新增一个描述，勾选如图配置，点击生成对应的 token 5. 设置GitHub Webhooks 新建或者设置现有项目的webhooks选项，url：你之前部署jenkins的服务器的IP+端口+ github-webhook,填写完成确认添加。 6. 设置Jenkins的全局Github配置 jenkins 安装Github Plugin插件,因为我们在配置jenkins的时候已经安装了所以这里可跳过， 如果没有 key 在jenkins 系统管理--&gt;插件管理--&gt;可选插件中安装。 jenkins 系统管理 --&gt; 系统设置 --&gt; GitHub --&gt; Add GitHub Sever,设置一下jenkins关联 GitHub。 注意：这里需要使用上面生成的令牌，使用用户名和密码不起作用，设置后选项内不会出现，已经验证过。 按照如下图选择添加配置，这个时候就需要用到了我们第一步生成的 GitHub Personal Access Token，填写完毕确认添加 选择生成的凭证，测试jenkins连接github服务器,如下图说明一切都配置 ok，最后记得在页面底部保存配置 7. jenkins的项目配置 jenkins 新建项目，选择构建自由风格项目 完成之后的页面如下，后面我们做关于项目的配置设置都是基于这样页面（后面可以在项目=&gt;配置中找到这个页面） 填写GitHub 项目URL 源码管理这里连接存储库可能会报错，首先检查服务器上是否安装了git，如果没安装需要安装上，应该可以解决问题，至少我遇到的是这样的。权限用户配置可以使用SSH,也可以HTTP登录名和密码的形式。 8.构建 构建的时候注意看下自己nginx上存放静态资源的地址是否和shell命令中的一致，如果不一致需要改正。 echo $PATH #输出环境变量，可以不要 node -v #输出node版本 ，可以不要 npm -v #输出npm版本，可以不要 cd /var/lib/jenkins/workspace/data-search #cd到项目目录 rm -rf node_modules/ #删除旧依赖 npm install chromedriver --chromedriver_cdnurl=http://cdn.npm.taobao.org/dist/chromedriver npm install npm run build cd dist tar -zcvf dist.tar.gz * #将dist包压缩 cd /usr/share/nginx/html #进入远程服务器的目录 shopt -s extglob #开启extglob模式，开启之后Shell可以另外识别出5个模式匹配操作符 rm -fr !(oraitStatic) #删除除了oraitStatic外的所有其他文件 shopt -u extglob #关闭extglob模式 scp /var/lib/jenkins/workspace/data-search/dist/dist.tar.gz /usr/share/nginx/html #把包发送到指定服务器目录 tar -zxvf dist.tar.gz #解压dist文件到当前文件夹 rm -rf dist.tar.gz #删除dist文件 应用，保存，ok。 ","link":"https://losetime.github.io/post/a-li-yun-centos-pei-zhi-jenkins/"},{"title":"CentOS安装Node.js","content":"Yum 自带 Node版本，但是版本太老了，是V6版本的，所以我们需要重新安装。 二进制安装方法，右击复制二进制文件链接地址 使用wget下载压缩文件，使用tar命令解压 wget https://nodejs.org/dist/v10.15.3/node-v10.15.3-linux-x64.tar.xz（文件在root文件夹下） tar -xvf v10.15.3/node-v10.15.3-linux-x64.tar.xz （解压，也在root文件夹下面） 配置环境变量 第一种方法 vim ~/.bashrc //打开文件 export PATH=/root/node-v10.15.3-linux-x64/bin:$PATH //添加PATH路径 source ~/.bashrc //刷新文件 第二种方法（添加软连接将安装目录链接到全局） ln -s /root/node-v9.8.0-linux-x64/bin/node /usr/local/bin/node ln -s /root/node-v9.8.0-linux-x64/bin/npm /usr/local/bin/npm ln -s /root/node-v9.8.0-linux-x64/bin/npx /usr/local/bin/npx ","link":"https://losetime.github.io/post/centos-an-zhuang-nodejs/"},{"title":"阿里云CentOS配置Nigux","content":" CentOS自带yum源，所以可以直接使用 安装 sudo yum install -y nginx 默认安装目录： /usr/share/nginx/ 启动 sudo stystemctl start nginx.service 开机启动 sudo systemctl enable nginx.service 网站文件存放默认目录 /usr/share/nginx/html 站默认站点配置 /etc/nginx/conf.d/default.conf 自定义Nginx站点配置文件存放目录 /etc/nginx/conf.d/ Nginx全局配置 /etc/nginx/nginx.conf 彻底卸载Nginx（其他软件相同） 停止Nginx软件 service nginx stop 删除Nginx的自动启动 chkconfig nginx off 从源头删除Nginx rm -rf /usr/sbin/nginx rm -rf /etc/nginx rm -rf /etc/init.d/nginx 再使用yum清理 yum remove nginx 11.安装软件（例如java） yum search java|grep jdk 或者： yum list 软件名 yum install java-1.8.0-openjdk 升级所有的软件包 yum update 升级某一个软件包 ，以升级 tomcat 为例 yum update tomcat 检查可更新的程序 yum check-update 查看所有进程 netstat -nap 杀死进程 kill PID编号 解决ssh服务器的x11 forwarding报错 ","link":"https://losetime.github.io/post/a-li-yun-centos-pei-zhi-nigux/"},{"title":"Flutter打包和个性化修改","content":" 生成keyStore keytool -genkey -v -keystore my-release-key.keystore -alias my-key-alias -keyalg RSA -keysize 2048 -validity 10000 注意：命令可能会找不到，那就要去java文件夹里去找，路径一般在 【C:\\Program Files\\Java\\jdk1.8.0_201\\bin】 然后执行 .\\keytool -genkey -v -keystore my-release-key.keystore -alias my-key-alias -keyalg RSA -keysize 2048 -validity 10000，就可以生成，生成的文件也会保存在这个目录下 -keystore 参数后的值： my-release-key.keystore， 表示一会儿要生成的那个 签名文件 的名称；请先保存好这个名称，因为后面发布项目期间会用到它。 -alias 参数后面的值：my-key-alias，后续发布项目期间也会用到，因此也需要保存好这个参数值；注意：这个参数的值可以根据自己的需要进行自定制。 当运行这个命令的时候，需要输入一系列的参数，和相关的口令的密码，一定要保存好相关的密码，后期会用到。 当生成了签名之后，这个签名，默认保存到了自己的用户目录下 C:\\Users\\用户名目录\\my-release-key.keystore 将自己的签名证书 copy 到 android/app 目录下。 注意：保持 keystore 文件的私密性； 不要将它加入到公共源代码控制中（最好的方式，是将 keystore 文件添加到 .gitignore 忽略文件）。 将生成的文件粘贴到项目中的【\\android\\app】之下就可以 找到/android目录，新建【key.properties】文件， 将以下代码写入该文件 storePassword=w1065427735（密码） keyPassword=w1065427735（密码） keyAlias=my-key-alias（-alias的值） storeFile=my-release-key.keystore（命令生成的文件名） 在gradle中配置签名 在【\\android\\app\\build.gradle】中的【apply from: &quot;$flutterRoot/packages/flutter_tools/gradle/flutter.gradle&quot;】之下添加代码： def keystorePropertiesFile = rootProject.file(&quot;key.properties&quot;) def keystoreProperties = new Properties() keystoreProperties.load(new FileInputStream(keystorePropertiesFile)) 在该文件中代码 buildTypes { release { // TODO: Add your own signing config for the release build. // Signing with the debug keys for now, so `flutter run --release` works. signingConfig signingConfigs.debug } } 替换为： signingConfigs { release { keyAlias keystoreProperties['keyAlias'] keyPassword keystoreProperties['keyPassword'] storeFile file(keystoreProperties['storeFile']) storePassword keystoreProperties['storePassword'] } } buildTypes { release { // TODO: Add your own signing config for the release build. // Signing with the debug keys for now, so `flutter run --release` works. signingConfig signingConfigs.release } } 修改app名称和图标 8.1 修改APP名称 在【\\android\\app\\src\\main】找到AndroidManifest文件， android:label=【项目名称】 8.2 修改图标 生成图标地址：https://icon.wuruihong.com/ 替换：找到【\\android\\app\\src\\main\\res】，替换下面的图片文件即可 在项目根目录下运行flutter run apk ","link":"https://losetime.github.io/post/flutter-da-bao-he-ge-xing-hua-xiu-gai/"},{"title":"Flutter_Swiper组件的使用","content":"import 'package:flutter/material.dart'; import 'package:flutter_swiper/flutter_swiper.dart'; class Home extends StatelessWidget{ @override Widget build(BuildContext context) { return new MaterialApp( title: '首页', theme: new ThemeData( primarySwatch: Colors.blue, ), home: new MyHomePage(title: '首页'), ); } } class MyHomePage extends StatefulWidget { MyHomePage({Key key, this.title}) : super(key: key); final String title; @override _MyHomePageState createState() =&gt; new _MyHomePageState(); } class _MyHomePageState extends State { List imageList = List(); @override void initState() { imageList ..add(Image.network( 'https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2726034926,4129010873&amp;fm=26&amp;gp=0.jpg', fit: BoxFit.fill, )) ..add(Image.network( 'https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=3485348007,2192172119&amp;fm=26&amp;gp=0.jpg', fit: BoxFit.fill, )) ..add(Image.network( 'https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2594792439,969125047&amp;fm=26&amp;gp=0.jpg', fit: BoxFit.fill, )) ..add(Image.network( 'https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=190488632,3936347730&amp;fm=26&amp;gp=0.jpg', fit: BoxFit.fill, )); super.initState(); } @override Widget build(BuildContext context) { return Scaffold( appBar: new AppBar( title: new Text(widget.title), ), body: ListView( children: [ firstSwiperView() ], ) ); } Widget firstSwiperView(){ return Container( // padding: const EdgeInsets.fromLTRB(0, 50, 0, 5), width: MediaQuery.of(context).size.width, height: 150, child: Swiper( itemCount: 4, itemBuilder: _swiperBuilder, pagination: SwiperPagination( alignment: Alignment.bottomRight, // margin: const EdgeInsets.fromLTRB(0, 0, 20, 10), builder: DotSwiperPaginationBuilder( color: Colors.black54, activeColor: Colors.white ) ), controller: SwiperController(), scrollDirection: Axis.horizontal, autoplay: true, onTap: (index) =&gt; print('点击了第$index'), ), ); } Widget _swiperBuilder(BuildContext context, int index){ return (imageList[index]); } } ","link":"https://losetime.github.io/post/flutter_swiper-zu-jian-de-shi-yong/"},{"title":"Flutter 通用模块","content":"https://www.jianshu.com/p/559d0b4edce5 ","link":"https://losetime.github.io/post/flutter-tong-yong-mo-kuai/"}]}