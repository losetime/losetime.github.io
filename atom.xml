<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://losetime.github.io</id>
    <title>losetime</title>
    <updated>2021-04-02T15:26:28.718Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://losetime.github.io"/>
    <link rel="self" href="https://losetime.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://losetime.github.io/images/avatar.png</logo>
    <icon>https://losetime.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, losetime</rights>
    <entry>
        <title type="html"><![CDATA[快速排序]]></title>
        <id>https://losetime.github.io/kuai-su-pai-xu/</id>
        <link href="https://losetime.github.io/kuai-su-pai-xu/">
        </link>
        <updated>2021-04-02T14:06:01.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://losetime.github.io/post-images/1617375144226.png" alt="" loading="lazy"></figure>
<pre><code>function quickSort(arr, l, r){
  if(l&gt;=r) return arr
  let left = l // 左指针
  let right = r //右指针
  let pivot = arr[left] // 基准值
  // 开启排序
  while(left &lt; right){  // 如果左指针小于右指针，才能继续，否则说明两个指针相遇了
    while(arr[left]&lt;pivot &amp;&amp; left&lt;right){
      left++
    }
    while(arr[right]&gt;pivot &amp;&amp; left&lt;right){
      right--
    }
    if(left&lt;right){
      [arr[left],arr[right]] = [arr[right],arr[left]]
    } else {
      arr[left]=pivot
    }
  }
  quickSort(arr, l, left-1)
  quickSort(arr, left+1, r)
  return arr
}
let sortArr = [2,1,4,3,9,12,100,201,29,80,72,92,54,32,23]
console.log(quickSort(sortArr, 0, sortArr.length-1))
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[实现一个任务队列]]></title>
        <id>https://losetime.github.io/shi-xian-yi-ge-ren-wu-dui-lie/</id>
        <link href="https://losetime.github.io/shi-xian-yi-ge-ren-wu-dui-lie/">
        </link>
        <updated>2019-07-16T03:00:02.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1promise实现任务队列">1.promise实现任务队列</h1>
<ul>
<li>promise.then如果遇到没有返回值，那么默认就会把undefined包装成promise后返回，然后继续向下执行</li>
<li>我们在返回值里 返回一个新的promise，那么第一层的promise就会等到这内部的promise执行完毕后才会返回</li>
<li>而内部的promise什么时候执行完成，就依赖于resolve何时执行，这就达到了任务队列的目的</li>
</ul>
<pre><code>1. forEach版本

function taskQueue(arr){
    let promise = Promise.resolve();
    arr.forEach(item=&gt;{
		//这里需要把返回的Promise实例赋给promise，生成新的队列
        promise = promise.then(()=&gt;{
            return new Promise(resolve=&gt;{
                // do...
                setTimeout(()=&gt;{
                    console.log(item)
                    resolve();
                },2000)
                
            })
        })
    })
}

2. reduce版本

function taskQueue(arr){
    /**
     * reduce方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终返回一个值
     * reduce中callback的返回值会作为下一次的初始值
     reduce参数
     * callback，回调函数
     * initialValue，初始传入值值
     callback参数
     * 1.previousValue,上一次调用回调返回的值，或者是提供的初始值
     * 2.currentValue，数组中当前被处理的元素
     * 3.index,当前元素在数组中的索引
     * 4.array,reduce调用的数组
     */
    arr.reduce((promise,item,index,array)=&gt;{
        return promise.then(()=&gt;{
            return new Promise(resolve=&gt;{
                setTimeout(()=&gt;{
                    console.log(item)
                    resolve();
                },2000)
            })
        })
    },Promise.resolve())
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue CLI Plugin Electron Builder笔记]]></title>
        <id>https://losetime.github.io/vue-cli-plugin-electron-builder-bi-ji/</id>
        <link href="https://losetime.github.io/vue-cli-plugin-electron-builder-bi-ji/">
        </link>
        <updated>2019-07-11T09:23:56.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1环境变量说明">1.环境变量说明</h3>
<p>vue.js中设置的【生产环境变量】和【线上环境变量】在electron打包是可用的</p>
<h3 id="2隐藏顶部菜单栏">2.隐藏顶部菜单栏</h3>
<figure data-type="image" tabindex="1"><img src="https://losetime.github.io/post-images/1562837171739.png" alt="" loading="lazy"></figure>
<h3 id="3使用electron-build在vue-cli-3中的使用">3.使用electron-build在vue-cli 3中的使用</h3>
<p>文档参考：https://nklayman.github.io/vue-cli-plugin-electron-builder/guide/#installation</p>
<p>安装完毕之后项目里会多出一些文件，其中有一个background.js，关于页面的东西需要去这个当中改</p>
<p>注意事项:node版本必须高于8.12，升级node版本后可以后导致node-sass这个模块的不可用，需要执行【npm rebuild node-sass】去重新绑定</p>
<h3 id="4窗口宽与高的固定">4.窗口宽与高的固定</h3>
<pre><code>win = new BrowserWindow({

    width: 400,

    height: 750,

    maxHeight:750,

    maxWidth: 400,

    webPreferences: {

      nodeIntegration: true

    }

 });
</code></pre>
<h3 id="4应用打包后打开调试工具">4.应用打包后打开调试工具</h3>
<p>方法一（主进程）：</p>
<pre><code>function createWindow (){   

mainWindow = newBrowserWindow({

width:800, 

height:600

})

mainWindow.webContents.openDevTools()

}
</code></pre>
<p>方法二（渲染进程）：</p>
<pre><code>const { remote } = require('electron')

remote.getCurrentWebContents().openDevTools()
</code></pre>
<h3 id="6替换图标">6.替换图标</h3>
<p>1.把图标放在public文件下</p>
<p>2.安装</p>
<p><code>yarn add --dev electron-icon-builder（需要科学上网）</code></p>
<p>3.添加命令：</p>
<p><code>&quot;electron:generate-icons&quot;: &quot;electron-icon-builder --input=./public/icon.png --output=build --flatten&quot;</code></p>
<p>4.生成：</p>
<p><code>yarn electron:generate-icons</code></p>
<p>5.会生成build文件，不要动</p>
<p>6.修改配置</p>
<h3 id="7打包配置科学上网很重要啊">7.打包配置（科学上网很重要啊）</h3>
<p>参考文章：https://www.jianshu.com/p/1dbb96bc8f37<br>
参考文档：https://www.electron.build/configuration/configuration</p>
<pre><code>module.exports = {
  pluginOptions: {
    electronBuilder: {
      builderOptions: {
        appId: &quot;com.example.app&quot;,
        productName: &quot;hsl-Download&quot;, //项目名，也是生成的安装文件名，即hsl-Download
        copyright: &quot;Copyright © 2019&quot;, //版权信息
        directories: {
          output: &quot;./dist&quot; //输出文件路径
        },
        win: {
          //win相关配置
          target: [
            {
              target: &quot;nsis&quot;, //利用nsis制作安装程序
              arch: [
                &quot;x64&quot;, //64位
                &quot;ia32&quot; //32位
              ]
            }
          ]
        },
        nsis: {
          oneClick: false, // 是否一键安装
          allowElevation: true, // 允许请求提升。 如果为false，则用户必须使用提升的权限重新启动安装程序。
          allowToChangeInstallationDirectory: true, // 允许修改安装目录
          installerIcon: &quot;./static/icon.ico&quot;, // 安装图标
          uninstallerIcon: &quot;./static/icon.ico&quot;, //卸载图标
          installerHeaderIcon: &quot;./static/icon.ico&quot;, // 安装时头部图标
          createDesktopShortcut: true, // 创建桌面图标
          createStartMenuShortcut: true, // 创建开始菜单图标
          shortcutName: &quot;hsl-Download&quot; // 图标名称
        }
      }
    }
  }
};
</code></pre>
<h3 id="8注意事项">8.注意事项</h3>
<p>1.mac版本必须在mac电脑电脑上打包</p>
<h3 id="9遇到的错误">9.遇到的错误</h3>
<p>1.打包时项目路径中不能有中文。报错如下：<br>
<img src="https://losetime.github.io/post-images/1563938293861.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树算法原理]]></title>
        <id>https://losetime.github.io/er-cha-shu-suan-fa-yuan-li/</id>
        <link href="https://losetime.github.io/er-cha-shu-suan-fa-yuan-li/">
        </link>
        <updated>2019-04-20T10:21:52.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-二叉树特点">1.  二叉树特点</h3>
<p>左子树 &lt; 父节点 &lt; 右子树</p>
<h3 id="2-中序遍历">2.  中序遍历</h3>
<p>先遍历左子树，再访问父节点，再遍历右子树, 可以实现从小到大的排序</p>
<h3 id="3-前序遍历">3. 前序遍历</h3>
<p>先访问父节点，再遍历左子树，再遍历右子树  可以实现复制一颗二叉树，比重新构建二叉树快十倍左右</p>
<h3 id="4-后序遍历">4. 后序遍历</h3>
<p>先遍历左子树，再遍历右子树，再访问父节点  可以应用到文件系统的中，先访问它的左右子树，最后来访问这个节点本身</p>
<h3 id="5-二叉树查找">5. 二叉树查找</h3>
<ul>
<li>最小值：递归查找左子树</li>
<li>最大数：递归查找右子树</li>
<li>具体数：先判断大于父节点还是小于父节点，如果小于父节点，进入左子树；如果大于父节点，进入右子树；递归查找</li>
</ul>
<h3 id="6-二叉树子节点的删除最终目标是保持二叉树的排序性">6. 二叉树子节点的删除,最终目标是保持二叉树的排序性</h3>
<h3 id="7具体实现">7.具体实现</h3>
<pre><code>function BinaryTree(){
		this.root = null;
		var Node = function(key){
				this.key = key;
				this.left = null;
				this.right = null;
		}
		var insertNode = function(node,newNode){
				if(newNode.key &lt; node.key){
						if(node.left === null){
								node.left = newNode;
						}else{
								insertNode(node.left,newNode)
						}
				}else{
						if(node.right === null){
								node.right = newNode
						}else{
								insertNode(node.right,newNode)
						}
				}
		}
		this.insert = function(key){
				let node = new Node(key);
				if(this.root === null){
						this.root = node;
				}else {
						insertNode(this.root,node);
				}
		}
		var inOrderTravelNode = function(node,callback){
				if(node!==null){
						inOrderTravelNode(node.left,callback);
						callback(node.key);
						inOrderTravelNode(node.right,callback);
				}
		}
		// 中序遍历
		this.inOrderTravel = function(callback){
				inOrderTravelNode(this.root,callback)
		}
		var searchNode = function(node,key){
				if(node === null){
						console.log(&quot;查找失败&quot;);
				}
				else if(node.key &gt; key){
						searchNode(node.left,key);
				}else if(node.key &lt; key){
						searchNode(node.right,key);
				}else {
						console.log(&quot;找到了&quot;);
				}
		}
		//具体值查找
		this.search = function(key){
				if(this.root !== null){
						searchNode(this.root,key);
				}
		}
		//查找右子树最小节点(也就是当前父节点的右子树的左子树)
		var findMinNode = function(node){
				if(node){
						while(node &amp;&amp; node.left !== null) {
								node = node.left;
						}
						return node;
				}
				return null;
		}
		var that = this;
		var removeNode = function(node,key){
				if(node === null){
						console.log(&quot;查找失败&quot;);
				}
				else if(node.key &gt; key){
						node.left = removeNode(node.left,key);
						return node;
				}else if(node.key &lt; key){
						node.right = removeNode(node.right,key);
						return node;
				}else {
						//没有子节点
						if(node.left === null &amp;&amp; node.right === null){
								node = null;
								console.log(&quot;该节点已删除&quot;);
								return node;
						}
						//一个子节点
						if(node.left === null){
								node = node.right;
								return node;
						} else if(ndoe.right === null) {
								node = node.left;
								return node;
						}
						// 两个子节点，从右子树里找到最小子节点，然后替换父节点的值，并删除这个最小子节点
						var minNode = findMinNode(node.right);
						node.key = minNode.key;
						node.right = removeNode(node.right,minNode);
						return node;
				}
		}
		//删除子节点
		this.remove = function(key){
				this.root = removeNode(this.root,key);
		}
}
let node = [10,3,5,6,7,2,12,4,18,9,1]
let binaryTree = new BinaryTree();
//创建二叉树
node.forEach(key=&gt;{
		binaryTree.insert(key);
})
var callback = function(key){
		console.log(&quot;中序遍历：&quot;+key);
}
// 中序遍历
binaryTree.inOrderTravel(callback);
// 二叉树查找子节点
binaryTree.search(7);
//二叉树删除子节点
binaryTree.remove(1);</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Jenkins配置邮件通知]]></title>
        <id>https://losetime.github.io/jenkins-pei-zhi-you-jian-tong-zhi/</id>
        <link href="https://losetime.github.io/jenkins-pei-zhi-you-jian-tong-zhi/">
        </link>
        <updated>2019-04-19T11:09:47.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-自带邮件配置">1. 自带邮件配置</h2>
<p>打开全局系统配置，配置Jenkins Location，见图。<br>
<img src="https://losetime.github.io/post-images/1555672361973.png" alt="" loading="lazy"><br>
全局系统配置，配置邮件通知，见图。<br>
这里说一下，怎么打开邮箱的SMTP服务，这是QQ邮箱的教程：https://jingyan.baidu.com/article/0f5fb099dffe7c6d8334ea31.html<br>
其他邮箱应该大同小异，可以去找找。不过建议不要用Gmail，会牵扯到科学上网的问题。<br>
<img src="https://losetime.github.io/post-images/1555672404765.png" alt="" loading="lazy"><br>
配置任务构建后操作<br>
打开单项任务的配置-----》构建后操作 ，选择下图<br>
<img src="https://losetime.github.io/post-images/1555672415099.png" alt="" loading="lazy"><br>
写入邮件地址即可，保存<br>
<img src="https://losetime.github.io/post-images/1555672421153.png" alt="" loading="lazy"><br>
收到的邮件如下图，可以看到，这只是构建中打印的日志文件，看起来太费劲。不过，如果你只是想知道构建是否失败了，这个还是可以用的。<br>
<img src="https://losetime.github.io/post-images/1555672428133.png" alt="" loading="lazy"></p>
<h2 id="2-插件extended-e-mail-notification配置">2. 插件Extended E-mail Notification配置</h2>
<p>这个插件增强了邮件功能，使邮件可以自定义，如果没安装就去搜索并安装一下，然后我们一起走一遍过程。</p>
<h3 id="说明一点如果你直接用插件配置是可以不用配置系统自带邮件的这个经过验证">说明一点：如果你直接用插件配置，是可以不用配置系统自带邮件的，这个经过验证。</h3>
<ul>
<li>首先，在系统设置里找到这个插件，然后如图所示配置<br>
<img src="https://losetime.github.io/post-images/1555672636498.png" alt="" loading="lazy"></li>
<li>点开上图【高级...】，配置如下图<br>
<img src="https://losetime.github.io/post-images/1555672660244.png" alt="" loading="lazy"></li>
<li>点开上图【Default Triggers】，根据需要选择发送邮件的条件，可以选择总是，也可以选择其他特殊情况。<br>
<img src="https://losetime.github.io/post-images/1555672664292.png" alt="" loading="lazy"></li>
<li>应用，保存。</li>
<li>打开任务配置，打开【构建后操作】列表<br>
<img src="https://losetime.github.io/post-images/1555672687607.png" alt="" loading="lazy"></li>
<li>设置触发条件<br>
<img src="https://losetime.github.io/post-images/1555672692305.png" alt="" loading="lazy"><br>
<img src="https://losetime.github.io/post-images/1555672696196.png" alt="" loading="lazy"></li>
<li>其他都可以不用动，应用，保存。</li>
<li>逻辑是我们在全局设置了配置好了模板，这边添加一个构建动作，然后执行就可以，也可以在这边配置基于项目的个性化需求。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Jenkins的在Liunx系统上的权限问题]]></title>
        <id>https://losetime.github.io/jenkins-de-zai-liunx-xi-tong-shang-de-quan-xian-wen-ti/</id>
        <link href="https://losetime.github.io/jenkins-de-zai-liunx-xi-tong-shang-de-quan-xian-wen-ti/">
        </link>
        <updated>2019-04-19T09:38:20.000Z</updated>
        <content type="html"><![CDATA[<p>由于Jenkins在安装的时候，会自动创建一个名为jenkins的普通账号，这个账号没有管理员权限。jenkins执行命令的时候，它也会使用这个账号。但是由于nginx这个文件夹是用户root创建的，所以jenkins账号默认是没有权限读写这个文件夹的。所以导致构建的项目总是在复制的时候失败。</p>
<h3 id="下来以centos系统为例修改jenkins配置文件">下来以centOS系统为例，修改Jenkins配置文件。</h3>
<ul>
<li>打开配置文件</li>
</ul>
<pre><code>vim /etc/sysconfig/jenkins
</code></pre>
<ul>
<li>修改$JENKINS_USER</li>
</ul>
<pre><code>$JENKINS_USER=&quot;root&quot;
</code></pre>
<ul>
<li>修改Jenkins相关文件夹用户权限</li>
</ul>
<pre><code>chown -R root:root /var/lib/jenkins
chown -R root:root /var/cache/jenkins
chown -R root:root /var/log/jenkins
</code></pre>
<ul>
<li>重启Jenkins服务并检查运行Jenkins的用户是否已经切换为root</li>
</ul>
<pre><code>service jenkins restart
</code></pre>
<ul>
<li>查看Jenkins进程所属用户</li>
</ul>
<pre><code>ps -ef | grep jenkins
</code></pre>
<h3 id="若显示为root用户则表示修改完成">若显示为root用户，则表示修改完成</h3>
<figure data-type="image" tabindex="1"><img src="https://losetime.github.io/post-images/1555669015905.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[阿里云CentOS配置Jenkins]]></title>
        <id>https://losetime.github.io/a-li-yun-centos-pei-zhi-jenkins/</id>
        <link href="https://losetime.github.io/a-li-yun-centos-pei-zhi-jenkins/">
        </link>
        <updated>2019-04-19T09:31:16.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-下载jenkins">1. 下载jenkins</h2>
<pre><code>#下载Jenkins库
wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat/jenkins.repo
#导入key
rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key
#安装Jenkins，`-y`参数：回答全部问题为是
yum install -y jenkins
#启动Jenkins服务
systemctl start jenkins   或者   service jenkins start

jenkins的安装地址： /var/lib/jenkins/
Jenkins目录、端口、工作目录等信息在： /etc/sysconfig/jenkins
</code></pre>
<p>注意：</p>
<ul>
<li>要安装java</li>
</ul>
<pre><code>yum install java-1.8.0-openjdk
</code></pre>
<ul>
<li>阿里云的安全组规则，千万要记得把阿里云的安全组规则里加上自己要访问的端口<br>
<img src="https://losetime.github.io/post-images/1555667114420.png" alt="" loading="lazy"></li>
<li>防火墙问题</li>
</ul>
<pre><code>cat   /var/log/jenkins/jenkins.log #查看安装日志安装没有问题
firewall-cmd --add-port=8080/tcp #将设置的端口防火墙关闭
</code></pre>
<h2 id="2-配置jenkis的端口">2. 配置jenkis的端口</h2>
<pre><code>vi /etc/sysconfig/jenkins
找到修改端口号：
JENKINS_PORT=&quot;8080&quot;  此端口不冲突可以不修改 
</code></pre>
<h2 id="3-启动jenkins">3. 启动jenkins</h2>
<pre><code>service jenkins start/stop/restart
</code></pre>
<h2 id="4-生成personal-access-token">4. 生成Personal Access Token</h2>
<p>进入github --&gt; setting --&gt;developers--&gt; Personal Access Token --&gt; Generate new token, 新建一个有读写权限的用户<br>
<img src="https://losetime.github.io/post-images/1555667272755.png" alt="" loading="lazy"><br>
新增一个描述，勾选如图配置，点击生成对应的 token<br>
<img src="https://losetime.github.io/post-images/1555667331338.png" alt="" loading="lazy"></p>
<h2 id="5-设置github-webhooks">5. 设置GitHub Webhooks</h2>
<p>新建或者设置现有项目的webhooks选项，url：你之前部署jenkins的服务器的IP+端口+ github-webhook,填写完成确认添加。<br>
<img src="https://losetime.github.io/post-images/1555667368433.png" alt="" loading="lazy"></p>
<h2 id="6-设置jenkins的全局github配置">6. 设置Jenkins的全局Github配置</h2>
<p>jenkins 安装Github Plugin插件,因为我们在配置jenkins的时候已经安装了所以这里可跳过， 如果没有 key 在jenkins 系统管理--&gt;插件管理--&gt;可选插件中安装。<br>
jenkins 系统管理 --&gt; 系统设置 --&gt; GitHub --&gt; Add GitHub Sever,设置一下jenkins关联 GitHub。<br>
<strong>注意：这里需要使用上面生成的令牌，使用用户名和密码不起作用，设置后选项内不会出现，已经验证过。</strong><br>
<img src="https://losetime.github.io/post-images/1555667469439.png" alt="" loading="lazy"><br>
按照如下图选择添加配置，这个时候就需要用到了我们第一步生成的 GitHub Personal Access Token，填写完毕确认添加<br>
<img src="https://losetime.github.io/post-images/1555667506907.png" alt="" loading="lazy"><br>
选择生成的凭证，测试jenkins连接github服务器,如下图说明一切都配置 ok，最后记得在页面底部保存配置<br>
<img src="https://losetime.github.io/post-images/1555667535586.png" alt="" loading="lazy"></p>
<h2 id="7-jenkins的项目配置">7. jenkins的项目配置</h2>
<ul>
<li>jenkins 新建项目，选择构建自由风格项目<br>
<img src="https://losetime.github.io/post-images/1555668168134.png" alt="" loading="lazy"></li>
<li>完成之后的页面如下，后面我们做关于项目的配置设置都是基于这样页面（后面可以在项目=&gt;配置中找到这个页面）<br>
<img src="https://losetime.github.io/post-images/1555668204875.png" alt="" loading="lazy"></li>
<li>填写GitHub 项目URL<br>
<img src="https://losetime.github.io/post-images/1555668275048.png" alt="" loading="lazy"></li>
<li>源码管理这里连接存储库可能会报错，首先检查服务器上是否安装了git，如果没安装需要安装上，应该可以解决问题，至少我遇到的是这样的。权限用户配置可以使用SSH,也可以HTTP登录名和密码的形式。<br>
<img src="https://losetime.github.io/post-images/1555668364154.png" alt="" loading="lazy"><br>
<img src="https://losetime.github.io/post-images/1555668389837.png" alt="" loading="lazy"><br>
<img src="https://losetime.github.io/post-images/1555668409918.png" alt="" loading="lazy"><br>
<img src="https://losetime.github.io/post-images/1555668427286.png" alt="" loading="lazy"></li>
</ul>
<h2 id="8构建">8.构建</h2>
<p>构建的时候注意看下自己nginx上存放静态资源的地址是否和shell命令中的一致，如果不一致需要改正。<br>
<img src="https://losetime.github.io/post-images/1555668533356.png" alt="" loading="lazy"></p>
<pre><code>echo $PATH  #输出环境变量，可以不要
node -v  #输出node版本 ，可以不要
npm -v #输出npm版本，可以不要
cd /var/lib/jenkins/workspace/data-search  #cd到项目目录
rm -rf node_modules/  #删除旧依赖
npm install chromedriver --chromedriver_cdnurl=http://cdn.npm.taobao.org/dist/chromedriver
npm install
npm run build
cd dist
tar -zcvf dist.tar.gz *  #将dist包压缩


cd /usr/share/nginx/html #进入远程服务器的目录
shopt -s extglob #开启extglob模式，开启之后Shell可以另外识别出5个模式匹配操作符
rm -fr !(oraitStatic) #删除除了oraitStatic外的所有其他文件 
shopt -u extglob #关闭extglob模式
scp /var/lib/jenkins/workspace/data-search/dist/dist.tar.gz /usr/share/nginx/html  #把包发送到指定服务器目录
tar -zxvf dist.tar.gz #解压dist文件到当前文件夹
rm -rf dist.tar.gz #删除dist文件
</code></pre>
<p>应用，保存，ok。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CentOS安装Node.js]]></title>
        <id>https://losetime.github.io/centos-an-zhuang-nodejs/</id>
        <link href="https://losetime.github.io/centos-an-zhuang-nodejs/">
        </link>
        <updated>2019-04-19T08:36:04.000Z</updated>
        <content type="html"><![CDATA[<p>Yum 自带 Node版本，但是版本太老了，是V6版本的，所以我们需要重新安装。</p>
<ol>
<li>二进制安装方法，右击复制二进制文件链接地址<br>
<img src="https://losetime.github.io/post-images/1555663662014.png" alt="" loading="lazy"></li>
<li>使用wget下载压缩文件，使用tar命令解压</li>
</ol>
<pre><code>wget https://nodejs.org/dist/v10.15.3/node-v10.15.3-linux-x64.tar.xz（文件在root文件夹下）
tar -xvf v10.15.3/node-v10.15.3-linux-x64.tar.xz （解压，也在root文件夹下面）
</code></pre>
<ol start="3">
<li>配置环境变量</li>
</ol>
<ul>
<li>第一种方法</li>
</ul>
<pre><code>vim ~/.bashrc   //打开文件
export PATH=/root/node-v10.15.3-linux-x64/bin:$PATH  //添加PATH路径
source ~/.bashrc  //刷新文件
</code></pre>
<ul>
<li>第二种方法（添加软连接将安装目录链接到全局）</li>
</ul>
<pre><code>ln -s /root/node-v9.8.0-linux-x64/bin/node /usr/local/bin/node  
ln -s /root/node-v9.8.0-linux-x64/bin/npm /usr/local/bin/npm  
ln -s /root/node-v9.8.0-linux-x64/bin/npx /usr/local/bin/npx
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[阿里云CentOS配置Nigux]]></title>
        <id>https://losetime.github.io/a-li-yun-centos-pei-zhi-nigux/</id>
        <link href="https://losetime.github.io/a-li-yun-centos-pei-zhi-nigux/">
        </link>
        <updated>2019-04-18T05:43:08.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>CentOS自带yum源，所以可以直接使用</li>
<li>安装</li>
</ol>
<pre><code>sudo yum install -y nginx
</code></pre>
<ol start="3">
<li>默认安装目录： /usr/share/nginx/</li>
<li>启动</li>
</ol>
<pre><code>sudo stystemctl start nginx.service
</code></pre>
<ol start="5">
<li>开机启动</li>
</ol>
<pre><code>sudo systemctl enable nginx.service
</code></pre>
<ol start="6">
<li>网站文件存放默认目录</li>
</ol>
<pre><code>/usr/share/nginx/html
</code></pre>
<ol start="7">
<li>站默认站点配置</li>
</ol>
<pre><code>/etc/nginx/conf.d/default.conf
</code></pre>
<ol start="8">
<li>自定义Nginx站点配置文件存放目录</li>
</ol>
<pre><code>/etc/nginx/conf.d/
</code></pre>
<ol start="9">
<li>Nginx全局配置</li>
</ol>
<pre><code>/etc/nginx/nginx.conf
</code></pre>
<ol start="10">
<li>彻底卸载Nginx（其他软件相同）</li>
</ol>
<ul>
<li>停止Nginx软件<br>
<code>service nginx stop</code></li>
<li>删除Nginx的自动启动<br>
<code>chkconfig nginx off</code></li>
<li>从源头删除Nginx</li>
</ul>
<pre><code>rm -rf /usr/sbin/nginx
rm -rf /etc/nginx
rm -rf /etc/init.d/nginx
</code></pre>
<ul>
<li>再使用yum清理<br>
<code>yum remove nginx</code></li>
</ul>
<p>11.安装软件（例如java）</p>
<pre><code>yum search java|grep jdk

或者： yum list 软件名

yum install java-1.8.0-openjdk
</code></pre>
<ol start="12">
<li>升级所有的软件包</li>
</ol>
<pre><code>yum update
</code></pre>
<ol start="13">
<li>升级某一个软件包 ，以升级 tomcat 为例</li>
</ol>
<pre><code>yum update tomcat
</code></pre>
<ol start="14">
<li>检查可更新的程序</li>
</ol>
<pre><code>yum check-update
</code></pre>
<ol start="15">
<li>查看所有进程</li>
</ol>
<pre><code>netstat -nap
</code></pre>
<ol start="16">
<li>杀死进程</li>
</ol>
<pre><code>kill PID编号
</code></pre>
<ol start="17">
<li>解决ssh服务器的x11 forwarding报错<br>
<img src="https://losetime.github.io/post-images/1555566876356.png" alt="" loading="lazy"></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Flutter打包和个性化修改]]></title>
        <id>https://losetime.github.io/flutter-da-bao-he-ge-xing-hua-xiu-gai/</id>
        <link href="https://losetime.github.io/flutter-da-bao-he-ge-xing-hua-xiu-gai/">
        </link>
        <updated>2019-04-08T04:34:59.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>生成keyStore</li>
</ol>
<pre><code>keytool -genkey -v -keystore my-release-key.keystore -alias my-key-alias -keyalg RSA -keysize 2048 -validity 10000
</code></pre>
<p>注意：命令可能会找不到，那就要去java文件夹里去找，路径一般在 【C:\Program Files\Java\jdk1.8.0_201\bin】</p>
<p>然后执行 .\keytool -genkey -v -keystore my-release-key.keystore -alias my-key-alias -keyalg RSA -keysize 2048 -validity 10000，就可以生成，生成的文件也会保存在这个目录下</p>
<p>-keystore 参数后的值： my-release-key.keystore， 表示一会儿要生成的那个 签名文件 的名称；请先保存好这个名称，因为后面发布项目期间会用到它。</p>
<p>-alias 参数后面的值：my-key-alias，后续发布项目期间也会用到，因此也需要保存好这个参数值；注意：这个参数的值可以根据自己的需要进行自定制。</p>
<p>当运行这个命令的时候，需要输入一系列的参数，和相关的口令的密码，一定要保存好相关的密码，后期会用到。</p>
<p>当生成了签名之后，这个签名，默认保存到了自己的用户目录下 C:\Users\用户名目录\my-release-key.keystore</p>
<p>将自己的签名证书 copy 到 android/app 目录下。</p>
<p>注意：保持 keystore 文件的私密性； 不要将它加入到公共源代码控制中（最好的方式，是将 keystore 文件添加到 .gitignore 忽略文件）。</p>
<ol start="2">
<li>
<p>将生成的文件粘贴到项目中的【\android\app】之下就可以</p>
</li>
<li>
<p>找到/android目录，新建【key.properties】文件，</p>
</li>
<li>
<p>将以下代码写入该文件</p>
</li>
</ol>
<pre><code>storePassword=w1065427735（密码）
keyPassword=w1065427735（密码）
keyAlias=my-key-alias（-alias的值）
storeFile=my-release-key.keystore（命令生成的文件名）
</code></pre>
<ol start="5">
<li>在gradle中配置签名<br>
在【\android\app\build.gradle】中的【apply from: &quot;$flutterRoot/packages/flutter_tools/gradle/flutter.gradle&quot;】之下添加代码：</li>
</ol>
<pre><code>def keystorePropertiesFile = rootProject.file(&quot;key.properties&quot;)
def keystoreProperties = new Properties()
keystoreProperties.load(new FileInputStream(keystorePropertiesFile))
</code></pre>
<ol start="6">
<li>在该文件中代码</li>
</ol>
<pre><code>buildTypes {
    release {
        // TODO: Add your own signing config for the release build.
        // Signing with the debug keys for now, so `flutter run --release` works.
        signingConfig signingConfigs.debug
    }
}
</code></pre>
<p>替换为：</p>
<pre><code>signingConfigs {
        release {
            keyAlias keystoreProperties['keyAlias']
            keyPassword keystoreProperties['keyPassword']
            storeFile file(keystoreProperties['storeFile'])
            storePassword keystoreProperties['storePassword']
            }
    }
    buildTypes {
        release {
            // TODO: Add your own signing config for the release build.
            // Signing with the debug keys for now, so `flutter run --release` works.
            signingConfig signingConfigs.release
        }
    }
</code></pre>
<ol start="7">
<li>
<p>修改app名称和图标<br>
8.1 修改APP名称<br>
在【\android\app\src\main】找到AndroidManifest文件， android:label=【项目名称】<br>
8.2 修改图标<br>
生成图标地址：https://icon.wuruihong.com/<br>
替换：找到【\android\app\src\main\res】，替换下面的图片文件即可</p>
</li>
<li>
<p>在项目根目录下运行flutter run apk</p>
</li>
</ol>
]]></content>
    </entry>
</feed>